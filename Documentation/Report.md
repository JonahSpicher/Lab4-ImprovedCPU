# CompArch Lab 3: Single Cycle CPU

Jonah Spicher and Melissa Guzman <br>
November 2019<br>

## Block Diagram
<br>
<img src="CPU.jpg" width="100%" height="400">

In our cpu design, we know that one instruction is completed per cycle so we implemented a program counter that keeps track of the instructions. The program counter fetches the instruction from memory. Each instruction has to be decoded, so we used a look up table to identify the type of instruction. Consider the load word operation: R[rt] = M[R[rs]+SignExtImm]. The look up table will look at bits 31-26, which is the op code, and determine that it’s a load word operation. This is an I-type instruction so the control signals will be specifically set to complete the instruction. The instruction is also split with bits assigned to the Rs register, Rt register and the 16 bit immediate. The operand still needs to be fetched so we use a register file. Since it’s an I-type, the control signal R (R-type) will be set low, which means that the write register in the register file will be set to Rt. The immediate has to be sign extended to 32 bits and the I control is set high so a mux will pass the extended immediate as one on the inputs to the ALU. The contents of register Rs will also be passed from the register file to the ALU. The look up table set the ALU control to the add operation so it will sum both inputs. The sum will then be used as the address in memory. Since the enable MemWren is set low, nothing will be stored in memory, but MemToReg is set high so the data from that address will be written back into register Rt in the register file. The control jl is set low so a mux will just load the data into register Rt. 

Now consider the jump and link operation: R[31]=PC+4;PC=JumpAddr. The program counter will fetch the instruction from memory. The look up table will look at the op code and determine it’s a JAL operation, so similarly the control signals will be specifically set to complete the instruction. This is a J-type instruction so there are 26 bits assigned to a jump address. The control signal jl is set high so a mux will pass register 31 for register Rt. The operand also needs to be fetched so we use a register file. The control signal jl is set high so another mux will pass the sum (using an adder) of program counter and 4 bytes into the register file as the writedata.  Since it’s an J-type, the control signal R (R-type) will be set low, which means that the write register in the register file will be set to Rt. The enable Wren is set high, so the data will be written into register 31. The program has to be updated to jump to the jump address. Bits 31-26 of the program counter will be concatenated with the jump address. The jr control signal is set low so the concatenated version is passed as an input to another mux where the J control signal is set high, causing the PC to jump to the new address since the output of the mux is looped back as an input to the program counter. 

Consider the branch on equal operation: if(R[rs]==R[rt]) PC=PC+4+BranchAddr. Similarly, the program counter will fetch the instruction from memory. The look up table will look at the op code and determine it’s a BEQ operation, so the control signals will be specifically set to complete the instruction. This is an I-type instruction so bits are assigned to the Rs register, Rt register and the 16 bit immediate. The operand needs to be fetched so we use a register file. Since it’s an I-type, the control signal R (R-type) will be set low, which means that the write register in the register file will be set to Rt. The immediate has to be sign extended to 32 bits, but the I control signal is set low this time because we want to compare the content in registers Rs and Rt, which are then passed from the register file to the ALU. The look up table set the ALU control to the subtract operation so it will subtract both inputs. If the values in both registers are identical then a zero flag will be raised. We used two AND gates, where one anded beq and zero and the other anded bne and not zero. The beq control signal was set high and the zero flag was raised so the first gate mentioned will output high while the other and gate outputs low. We also used an OR gate that ored these values. The OR gate will thus output high for the select of a mux. The mux will then pass the extended immediate, which is just the branch address, to an adder. The adder will sum the branch address, the PC, and 4 bytes. The J control was set low, so this sum is looped back to the PC, which means it branches to the new address.

Now consider the R-type instruction add: R[rd] = R[rs] + R[rt]. The program counter will fetch the instruction from memory. The look up table will look at the op code and the funct code and will determine it’s an add operation, so the control signals will be specifically set to complete the instruction. The instruction is also split with bits assigned to the Rs register, Rt register, and the Rd register. The operand still needs to be fetched so we use a register file. Since it’s a R-type, the control signal R will be set high, which means that the write register in the register file will be set to Rd. The I control signal was set low so a mux passes the content from register Rt to the ALU. The content from register Rs is also passed to the ALU. The look up table set the ALU control to the add operation so it will sum both inputs. Nothing needs to be stored or loaded from memory and the control signal MemtoReg is set low, so a mux will just pass the sum from the ALU back to the register file. Since the LUT set the Wren enable of the register file high and the jl control signal is low a mux will just pass the sum to the register file to get written into register Rd. 

The remaining instructions follow somewhat similar processes, but the ones we highlighted above demonstrate different parts of our CPU design being used for the three different instruction types. 

## Test Plan & Results

For the CPU, we tested it using three assembly programs: Multiply.asm, LCM.asm, and exp.asm.

We first tested the cpu with Multiply.asm, which multiplied 5 by 5. This test implemented the instructions: ADDI, BEQ, ADD, and J. In addition, within the test bench file of the cpu we used three different start signals, one per assembly test, because we need to make sure that each test is executed one at a time and do not overlap. This is why start1 is initially high for the multiplication test. We created a separate module for this specific test in which we check if test_triggered is low, the start signal is high, and if the reg write address is register 2 ($v0) since the accumulated value is stored there at the end of the program. If the condition is true, we set test_triggered high and then check if the result obtained equals 25. If it does then we simply print that this test was successful. If it does not equal 25, then we print an error message and set test_failed1 high. Outside of the module after its instantiation we read from memory. We also check if test_failed1 and other test_failed signals outputted from the test modules are high. If so this means that our CPU failed some or all tests. On top of this, we have a condition that checks if test_triggered remained low, meaning that the reg write address was never register 2. If so we display the message that the assembly test timed out. This test case was useful in catching when our program entered infinite loops.

The second test (LCM)  was slightly more complicated, involving the SLT instruction as well as more looping and a greater number of instructions, but overall just served as an additional example of basic functionality. It took two numbers (4 and 6) and found their least common multiple (12). Similarly to the first test, a start signal triggered the events which prepared the CPU to execute the program, and a tester module watched for the end conditions, with a similar check for an infinite loop/timeout or a bad result. 

The third test was much more complicated (and uncovered numerous bugs which the other two programs did not). It made heavy use of the lw and sw instructions in order to implement two separate functions, one of which was recursive (exponentiation) and called the other (multiply). This test had multiple triggers to watch for, as the result of each function call was stored in a separate register, but checks for bad results, infinite loops, and timeouts were still implemented. 

The test bench cpu.t.v loads each program into memory one after the other. We were unfamiliar with how loadmemh worked, so we started with the smallest program, assuming that loading in new memory would overwrite the old programs (but ensuring that if the empty space after instructions was not written to memory, no problems would occur). A reset signal was used to clear the register files and restart the program counter. 

### Test Informed Decisions 
Running the assembly uncovered numerous bugs in our design, some subtle and others more intrusive. The first issue was a problem in a dependency of the register file, where a register was not by default set to 0. This caused a series of undefined states to ripple through the CPU at unexpected times. 

An issue in memory was uncovered only by extensively and closely analyzing the results of the exponential function assembly test. At this point in the design, the LCM and multiplication .asm files were running successfully. The first few calls of the exp function also ran, but as soon as the power was 2 or greater, it failed to execute and got caught in an infinite loop. The issue was revealed by the test bench to be in memory, $sp would be loaded out of memory as the wrong value. The issue was that the data_addr port was always being fed 0, meaning that all data written to memory was immediately overwritten by the next store word instruction. This meant that any program which only needed to store one word on the stack at a time would execute successfully, but 2 or more consecutive pushes resulted in errors. The issue was caused by a “solution” to the warnings thrown by memory.v. A logic error was made when trying to only feed the ALU result to data_addr when MemtoReg was on, which resulted in data_addr always receiving zero. In the end, this was solved by removing the warnings. 

### Results
The CPU works. All submodules pass their tests and the CPU successfully executes three separate programs of varying degrees of complexity. 

### Running the Tests
A Makefile allows a few commands to run a suite of tests from the verilog subfolder. We recommend "make runAuto," as this command runs all of the test benches exluding the look up table (the LUT does not report its own success and clutters the terminal). If you want to see all, including the LUT, "make runAll" will run all test benches. "make run" will run only the cpu test. 

## Design Reuse:
Multiple components of this design were reused. They are listed below and credited:
- The ALU created by Jonah’s lab 1 team was used, though a new test bench was written and a minor bug was fixed. 
- The decoder was provided in Homework 4. 
- The multiplexer.v file contains four multiplexers, three of which are reused from old labs (as they are used by components which have been reused, such as the ALU).
- The register file (as well as register.v) was taken from one of our homework 4’s, as well as the test bench (though minor edits to the test bench were made.


## Performance/Area Analysis 
As far as timing goes, the main factor determining how fast the design is is the clock cycle time. In a single cycle CPU, the length of a clock cycle has to be long enough for all processes to happen. From previous lab analysis, the worst case delay of the ALU (one of the slower portions of the design) is 1540 time units (assuming 10 delay units per input to each gate). The longest path occurs when an immediate is sign extended, fed through a multiplexer (20 more units) into the the ALU, where it meets a signal which was read from the register file after being selected by the lookup table (with 11 inputs and 13 outputs, making a delay of 200 units for a single instruction a safe guess). This register value must be read before the ALU operation can really start. Then, the output is fed through two more two input mux's (40 more units) before it reaches the register file and can wait for the next clock cycle. This should all happen much more slowly than the instruction fetch and branching process, and adds to a total of roughly 1820 "delay units." If we assume, as we have in the past, that 1 delay unit is 1 us, this means the clock needs about 1.8 ms between pulses, plus hold time, making for a clock speed of roughly 500 hz. This is not exactly impressive, but it is faster than *I* can do math. 

(We were unable to get any data on area from vivado).
